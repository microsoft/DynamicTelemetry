---
author: "Chris Gray"
status: ReviewLevel1
description : Demo Showing DurableID
---

# Cost Reduction Demo : Inline KQL Filtering

Dynamic telemetry can be used for many applications and in this one we
will use it to reduce the cost of our services locating and dropping a
highly verbose log message very quickly.

## Demo Overview

In short this demo will

-   Use Azure Monitor and KQL language to locate an unexpectedly
    expensive Open Telemetry log.

-   Utilize the DurableID feature on OpenTelemetry, to locate the line
    of code responsible for the expense.

-   Instruct Dynamic Telemetry to convert the Log into a Metric

-   Choose one of the five dynamic telemetry locations to apply our KQL
    filter.

-   Deploy the conversion, and measure the impact

## Use Azure Monitor and KQL language to locate an unexpectedly expensive Open Telemetry log

By using the query below in Application Insights, we can utilize the
durable identifier found in our logs to pinpoint specific log messages
or identify any log messages that are particularly resource-intensive.
This is an example, so none of these logs are notably expensive.

However, in a real production environment with millions or billions of
rows, you will observe more significant instances.

![](../orig_media/Demo.1.DurableID.SummarizeContrast.png){width="5.5in"
height="4.4303149606299215in"}

With the event name in hand (LogLaunch), one can appreciate the value of
having a durable identifier. What was once multiple pages of rows has
now been streamlined into only five rows. Some of these event names are
generated by the network infrastructure itself, while the second and
fourth ones are produced by our demonstration program.

It is noticeable that the counts of the empty row are slightly higher
compared to the log launch row. This discrepancy arises because not
every log row corresponds to a log launch. This observation further
underscores the point; in this instance, nine messages have been
aggregated into a single entry. In a production system, one can expect
this number to be significantly higher, which would subsequently
increase potential confusion exponentially.

## Utilize the DurableID feature on OpenTelemetry, to locate the line of code responsible for the expense.

It should be immediately apparent that using a durable identifier
instead of a regular expression is significantly faster and more
cost-effective than using flattened strings.

As shown in the figure above, nearly 3500 messages originate from a
single line of code, accounting for approximately 50% of all logging
activities.

Although this is a constructed example, it is not uncommon for around 8
lines of code to be responsible for about 50% of log-based telemetry.

We can efficiently search our source code for this function by utilizing
our source editor or various tools similar to grep.

Consider the utility of static analysis tools that process your DLLs.
These tools can easily identify mistakes like leaked secrets, such as IP
addresses, MAC addresses, or user identifiers.

![A screenshot of a computer AI-generated content may be
incorrect.](../orig_media/Demo.1.DurableID.Searching.png){width="5.0in"
height="3.9993055555555554in"}

Which will quickly disc     

``` cdocs_include
{{ CSharp_Include("../Samples/DurableIds/Pages/Index.cshtml.cs",
    "// StartSearchExample:LogLaunch",
    "// EndSearchExample:LogLaunch")
}}
```
The tool will efficiently identify the specific line of code, almost as if it were equipped with a GPS. In future versions of .NET and dynamic telemetry, one could envision a tool capable of processing debug symbols and utilizing reflection on the DLLs to pinpoint the exact build and line of code. This subject is discussed in greater detail in the relevant sections on durable identifiers. 

## Instruct Dynamic Telemetry to convert the Log into a Metric

## Choose one of the five dynamic telemetry locations to apply our KQL filter.

## Deploy the conversion, and measure the impact

## Recap
