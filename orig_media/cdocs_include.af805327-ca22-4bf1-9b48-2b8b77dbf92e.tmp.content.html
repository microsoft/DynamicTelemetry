<p>using Microsoft.AspNetCore.Mvc.RazorPages; using
System.Diagnostics.Metrics;</p>
<p>namespace DynamicTelemetry_Demo_DurableIds.Pages { public partial
class IndexModel : PageModel { private readonly ILogger<IndexModel>
_logger; private static string _version = “0.0.4”; private Guid
_instanceID = Guid.NewGuid(); //private static Counter<int> ?
_getCounter;</p>
<pre><code>    public IndexModel(ILogger&lt;IndexModel&gt; logger, IMeterFactory meterFactory)
    {
        _logger = logger;

        //var meter = meterFactory.Create(&quot;DynamicTelemetry.Metric.Conversion&quot;);
        //_getCounter = meter.CreateCounter&lt;int&gt;(&quot;LogLaunch&quot;);

        // On Launch emit two logs - seemingly identical, one has a DurableID
        //_getCounter.Add(1);
        LogWithDurableID();
        LogWithoutDurableID();
    }

    // StartExample:NoDurableId
    private void LogWithoutDurableID()
    {
        //
        // Log a message without a DurableID;  while simple, this log will provide struggles later
        //    because while we receive a property bag of the variables (_version), we will not know
        //    which line of code emitted the telemetry - as our only identtifer will be the
        //    &#39;flattened&#39; payload string
        //
        // NOTE: adding the _instanceID is to showcase how, once &#39;flattened&#39; this unrecommendable
        //    method of logging makes for tricky (and expensive) backend searching
        //
        _logger.LogInformation($&quot;Launch, ver={_version}, instantion={_instanceID}&quot;);
    }
    // EndExample:NoDurableId


    // StartExample:DurableId
    private void LogWithDurableID()
    {
        //
        // Log a message with a DurableID; &#39;behind the scenes&#39; the dotnet compiler will
        //     generate two ID&#39;s - one numerical, and one a string
        //
        // Behind the scenes, the compiler uses this syntax to create identifiers that are included
        //     into the telemetry row, that can be used visually, and in automation, to map
        //     from row of telemetry, to line of code - very useful when extending the capabilities
        //     of your telemetry assets
        //
        // NOTE: adding the _instanceID is to showcase how, we can more easily locate this line
        //     of code, as compared with the earlier &#39;flattened&#39; version.  The compiler will attach
        //     an &#39;EventName&#39; property with the value of our function name &quot;LogLaunch&quot;.  We can use this
        //     instead of regular expressions to locate and aggregate
        //
        LogLaunch(_logger, _version, _instanceID);
    }

    // StartSearchExample:LogLaunch
    [LoggerMessage(Level = LogLevel.Information, Message = &quot;Launch, ver={version}, instantion={instantionID}&quot;)]
    static partial void LogLaunch(ILogger logger, string version, Guid instantionID);
    // EndSearchExample:LogLaunch
    // EndExample:DurableId
}</code></pre>
<p>}</p>
